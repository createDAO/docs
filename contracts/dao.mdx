---
title: 'DAO Contract'
description: 'Reference for the DAO.sol implementation contract.'
---
import { Accordion, AccordionItem } from '/snippets/accordion.mdx';

Source: [`contracts/DAO.sol`](https://github.com/createdao/createdao-contracts/blob/main/contracts/DAO.sol) *(Note: Update link if necessary)* \
Inherits: `DAOProposals`, `DAOExecutor`

The `DAO.sol` contract is the core implementation logic for a DAO deployed via the `DAOFactory`. It acts as the central governance hub, orchestrating proposal creation, voting, and execution. It does not hold funds directly but controls the associated `DAOTreasury`, `DAOStaking`, and `DAOToken` contracts. This contract is intended to be used behind a `DAOProxy`.

## Key Concepts

*   **Governance Engine:** Combines proposal lifecycle management (from `DAOProposals`) and execution logic (from `DAOExecutor`).
*   **State Management:** Uses ERC-7201 namespaced storage (`CoreStorage`, `ProposalStorage`) inherited from its parent contracts to manage DAO settings (name, voting period, quorum, etc.) and proposal data.
*   **Module References:** Stores the addresses of the DAO's specific Token, Treasury, and Staking contract proxies.
*   **Upgradeability:** Implements the UUPS pattern. Upgrades are authorized only via successful governance proposals (`proposeUpgrade`) executed through the `execute` function, or directly by the owner during initial setup (before ownership is transferred to the DAO itself).

## Initialization

The `DAO` implementation is initialized via its proxy by the `DAOFactory` during the `createDAO` process.

```solidity
function initialize(
    string memory _name,
    address _treasury,
    address _stakingContract,
    address _token,
    address _factory
) external initializer;
```
*   Sets the DAO's name and references to the factory and associated module contracts.
*   Initializes default governance parameters (e.g., `votingPeriod`, `minProposalStake`, `quorum`). These can be changed later via governance proposals (if such proposal types are implemented).
*   Initializes Ownable and UUPSUpgradeable components. Ownership is initially set to the factory and then transferred to the DAO proxy address itself upon successful deployment completion in the factory.

## Key Functions

The `DAO.sol` contract itself primarily serves as the container. Most user-facing functions are inherited from `DAOProposals` and `DAOExecutor`.

<Accordion title="Proposal Creation Functions (from DAOProposals)">
These functions allow staked users to create different types of governance proposals. They all return a `proposalId`.

*   `proposeTransfer(address token, address recipient, uint256 amount)`: Propose transferring ETH (token = address(0)) or ERC20 tokens from the Treasury.
*   `proposeUpgrade(string calldata newVersion)`: Propose upgrading all core contracts (DAO, Token, Treasury, Staking) to a new implementation version registered in the Factory.
*   `proposeModuleUpgrade(IDAOModule.ModuleType moduleType, address moduleAddress, string calldata newVersion)`: Propose upgrading an optional module (e.g., Presale) to a new implementation version.
*   `proposePresale(uint256 tokenAmount, uint256 initialPrice)`: Propose deploying a new `DAOPresale` contract, funded with tokens from the Treasury.
*   `proposePresalePause(address presaleContract, bool pause)`: Propose pausing or unpausing a specific `DAOPresale` contract associated with the DAO.
*   `proposePresaleWithdraw(address presaleContract)`: Propose withdrawing collected funds from a specific `DAOPresale` contract to the Treasury.
*   `proposePause()`: Propose pausing the DAO's core functions (e.g., proposal creation).
*   `proposeUnpause()`: Propose unpausing the DAO.
</Accordion>

<Accordion title="Voting Function (from DAOProposals)">
*   `vote(uint256 proposalId, bool support)`: Allows users with voting power (derived from the Staking contract) to cast their vote on an active proposal. Reverts if the user has already voted or the voting period has ended.
</Accordion>

<Accordion title="Execution Function (from DAOExecutor)">
*   `execute(uint256 proposalId)`: Executes a proposal that has successfully passed (voting period ended, quorum reached, more 'for' votes than 'against'). Calls the appropriate internal execution logic based on the proposal type (e.g., `_executeTransfer`, `_executeUpgrade`). Can be called by anyone.
</Accordion>

<Accordion title="Emergency Function (from DAOExecutor)">
*   `emergencyWithdraw(address token, address recipient, uint256 amount)`: Allows the DAO (via `address(this)`) to withdraw funds from the Treasury *only when the DAO is paused*. This is a safeguard mechanism.
</Accordion>

<Accordion title="View Functions (from DAOProposals / IDAOBase)">
These functions allow anyone to read the state of the DAO and its proposals.

*   `getProposal(uint256 proposalId)`: Returns details about a specific proposal (type, votes, end time, executed status).
*   `getTransferData(proposalId)`, `getUpgradeData(proposalId)`, `getPresaleData(proposalId)`, etc.: Return data specific to different proposal types.
*   `name()`: Returns the DAO's name.
*   `factory()`: Returns the address of the `DAOFactory` that deployed this DAO.
*   `upgradeableContracts(IDAOBase.UpgradeableContract contractType)`: Returns the address of the associated Token, Treasury, or Staking contract proxy.
*   `proposalCount()`: Returns the total number of proposals created.
*   `votingPeriod()`: Returns the duration for voting on proposals.
*   `minProposalStake()`: Returns the minimum amount of staked tokens required to create a proposal.
*   `quorum()`: Returns the minimum percentage of total staked tokens that must vote on a proposal for it to be considered valid (represented as basis points, e.g., 5000 = 50%).
*   `paused()`: Returns true if the DAO is currently paused.
*   `version()`: Returns the version string of the `DAO.sol` implementation contract.
</Accordion>

## Events

The `DAO` contract inherits and utilizes events defined in `DAOEvents.sol` (via its parent contracts) to signal significant actions:
*   `ProposalCreated`
*   `Voted`
*   `ProposalExecuted`
*   `DAOPaused` / `DAOUnpaused`
*   `TransferProposalCreated`, `UpgradeProposalCreated`, etc. (Specific proposal type events)
*   `TransferExecuted`, `UpgradeExecuted`, etc. (Specific execution events)

## Upgradeability

Upgrades to the `DAO` logic are handled via the `proposeUpgrade` governance proposal type. When such a proposal is executed, the `_executeUpgrade` function within `DAOExecutor` calls `upgradeToAndCall` on the `DAOProxy` address, pointing it to the new `DAO.sol` implementation address specified in the proposal (which must match an implementation registered in the `DAOFactory`). The `_authorizeUpgrade` function ensures this can only happen during the execution of a valid proposal.
